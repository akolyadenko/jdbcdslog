#labels Featured
[UserGuide#Obtaining_the_library_jar Obtaining the library jar]
 * [UserGuide#Obtaining_the_pre-packaged_release Obtaining the pre-packaged release]
 * [UserGuide#Obtaining_the_pre-packaged_release_distro Obtaining the pre-packaged release distro]
 * [UserGuide#Obtaining_the_most_up-to-date_version_from_SVN Obtaining the most up-to-date version from SVN]
 * [UserGuide#Compiling_library_using_your_JDK_installation Compiling library using your JDK installation]
 * [UserGuide#Obtaining_dependencies Obtaining dependencies]
[UserGuide#Installing Installing]
[UserGuide#Configuring Configuring]
 * [UserGuide#Setup_logging_proxy Setup logging proxy]
  * [UserGuide#Manually_wrap_the_JDBC_Connection_object_in_the_code Manually wrap the JDBC Connection object in the code]
  * [UserGuide#Using_JDBC_Driver_Proxy Using JDBC Driver Proxy]

=Obtaining the library jar=

There are three options for obtaining the files for the library. 
 
 * Obtaining the pre-packaged release
 * Obtaining the pre-packaged release distro
 * Obtaining the most up-to-date version from SVN

==Obtaining the pre-packaged release jar==

Most developers will want to use a pre-packaged release, which are typically the most stable versions of the library. 

Click on the Downloads tab to download the latest stable library jar. It has only direct dependency on slf4j-api library which can be obtained from [http://www.slf4j.org/ slf4j project's page].

==Obtaining the pre-packaged release distro==

You can also get a zipped archive of the entire project including dependencies, sources and unit tests on the Downloads tab. After extracting the library from the zipped archive, you can find entire library jar file in the folder with name 'target'. 

==Obtaining the most up-to-date version from SVN==

The most up-to-date version of the code is available from this project's SVN repository. Obtaining the code via SVN enables developers to get early access to fixes or features that have not yet been released in the pre-packaged version or for developers who want to contribute patches back to the project. Note that SVN releases are not guaranteed to be stable -- the code may be buggy and certain interfaces may change before the next release.

Obtain the code by using the one of SVN checkout commands listed on Source tab (you will need an SVN client installed on your computer)

==Compiling library using your JDK installation==

You may need to compile the library in two cases:

 * you got sources from SVN (it doesn't contain jar file)
 * you need to run the library with older Java versions (release files contain library compiled using Java 6)

In this case you need to install and set up Maven on your computer, then navigate to project's directory and run mvn package command. After these steps you will find library jar in 'target' directory.

If you need to specify the path to your target JDK manually, you may specify it in pom.xml file in the project's root directory. The path to your JDK javac binary and compiler version should be specified in 'maven-compiler-plugin' plugin settings, for example:

{{{
<project>
...
<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<verbose>true</verbose>
					<fork>true</fork>
					<executable>/usr/lib/jdk1.4/bin/javac</executable>
					<compilerVersion>1.4</compilerVersion>
				</configuration>
			</plugin>
...
</build>
</project>
}}}

==Obtaining dependencies==

After you got the library jar file, you will need to get the dependencies. Currently jdbcdslog directly depends only on 1.5.10 version of [http://www.slf4j.org/ slf4j] library. You will need to download the slf4j-api-1.5.10.jar file from [http://www.slf4j.org/ slf4j project's page].

=Installation=

To install the jdbcdslog you just need to place library's jar and dependencies to classpath of your application.

Initially you need to put jdbcdslog-0.1.jar and slf4j-api-1.5.10.jar to classpath. You may need to put other dependencies files depends on logging engine you will choose for the logging. Please look at logging section for more details. 

=Configuring=

You need to configure two things in order to use the jdbcdslog library:

 * setup logging proxy
 * setup logging engine

==Setup logging proxy==

There are three use cases of jdbcdslog usage:

 * you can manually wrap JDBC Connection object in your code
 * you can setup logging JDBC Driver proxy
 * you can setup logging JDBC !DataSource proxy

===Manually wrap the JDBC Connection object in the code===

The simplest scenario is to just wrap the existing JDBC Connection. You can do something like following in your code:

{{{
Connection loggingConnection = ConnectionLoggingProxy.wrap(originalConnection);
}}}

That's it. Now all JDBC calls passed through loggingConnection object will be intercepted and logged.

===Using JDBC Driver Proxy==

In addition you can use JDBC Driver Logging Proxy. It will log all JDBC calls and transfer it to original JDBC Driver at the same time. 

In this case you should use {{{org.jdbcdslog.DriverLoggingProxy}}} instead of the original JDBC Driver class and use jdbcdslog URL format for connection URL parameter:

{{{jdbc:jdbcdslog:<original URL>;targetDriver=<original JDBC driver full class name>}}}

In example following original connection URL

{{{jdbc:hsqldb:mem:mymemdb}}}

should be transformed to 

{{{jdbc:jdbcdslog:hsqldb:mem:mymemdb;targetDriver=org.hsqldb.jdbcDriver}}}

After this all JDBC connections for new URL will use ldbcdslog logging proxy, all JDBC calls wil be logged and transfered to your original JDBC driver.

===Setup logging JDBC DataSource proxy===

Also you can setup logging on DataSource level. The idea is the same as for JDBC Driver Proxy -- jdbcdslog DataSource proxy intercepts and log all JDBC calls.

In this case you should use {{{org.jdbcdslog.ConnectionPoolXADataSourceProxy}}} class instead of your original DataSource class and pass additional parameter {{{targetDS}}} to the DataBase or URL setting for DataSource. 

In example if our original URL is {{{jdbc:hsqldb:mem:mymemdb}}}, then you should transform it to {{{jdbc:hsqldb:mem:mymemdb;targetDS=<original DataSource full class name>}}}.